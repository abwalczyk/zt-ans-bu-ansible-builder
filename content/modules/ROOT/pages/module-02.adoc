= üëã Introduction

In this section we will create an execution environment using `ansible-builder`.  
You will notice that this section only has the *VS Code* tab enabled ‚Äî this is because we will not be using Automation Hub to pull collections for this challenge.

[NOTE]
====
A quick note before we dive in: the editor we are using is VS Code and it may be unfamiliar for some folks.  
But we will keep the instructions simple enough and gradually build upon what we are doing in each challenge.  
If you are confused at any time, there is a folder called `solution-definition` adjacent to `execution-environment.yml` which will have the solution for each challenge.  
You can copy and replace content for your current definition file if you are unable to solve any YAML errors.
====

For this challenge we are doing a basic execution environment and the collection will be pulled from the community Galaxy (`galaxy.ansible.com`), which is the default hub to pull collections from.  
Our task for this challenge is to create an execution environment with the `ansible.netcommon` collection from Ansible Galaxy on top of the minimal execution environment.

In the next challenges we will show how to inform `ansible-builder` to pull collections from Automation Hub.

Please go through the tasks in this challenge to understand how to interact with `ansible-builder` v3.

== ‚òëÔ∏è Task - The definition file

On the *VS Code* tab on the left side you will see that we have a tab called "file." Click File->Open folder and select the directory opened called `minimal-downstream-from-galaxy` and this directory has a file called `execution-environment.yml`.

This file is our execution environment definition file, and the default name for this file is `execution-environment.yml`.  
By *default* we mean that if we just run the `build` subcommand of `ansible-builder` in this directory, `ansible-builder` will understand that it needs to look at this file for the definition of the execution environment it needs to create.

[NOTE]
====
For this task we have created an empty `execution-environment.yml` file for you, but in usual scenarios a user will have to create this directory as well as this file.
====

You can also create any file name you want, but if you change the file name you will have to inform `ansible-builder` which file to pick the definition from.  
Information on this is available in the `ansible-builder build --help` command.  
Here‚Äôs an example of a different definition file name:

[source,text]
----
  -f FILENAME, --file FILENAME
The definition of the execution environment (default: execution-environment.yml)
----

Suppose we create the definition file as `ee-definition.yml`, then we can run the following command to build the execution environment:

[source,shell]
----
ansible-builder build -f ee-definition.yml
----

The above command will not do anything in this lab, and if you run it you‚Äôll see an error saying that `ee-definition.yml` is not found.  
For this lab, we will stick to the default name `execution-environment.yml` for the definition file.

== ‚òëÔ∏è Task - Adding version to the definition file

As we mentioned that we are using `ansible-builder` version 3.0.0 for this lab, this also means that to take advantage of features provided with this version you need to add an identifier in the definition file.  
If you don't do this, `ansible-builder` v3 will fail to understand the schema of the definition and some keys that are newly introduced, resulting in failures.

For this task, just add the following line to the `execution-environment.yml`:

[source,yaml]
----
version: 3
----

== ‚òëÔ∏è Task - Adding the Base image

Execution environments are container images acting as Ansible environments.  
An important aspect for the definition file is to define a base image that the builder will use to build an EE.  
Think of this step as the starting point for your execution environment, and then we keep adding things on top.

Add this to the `execution-environment.yml` after the version line:

[source,yaml]
----
images:
  base_image:
    name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest
----

Now you might be asking yourself what image this refers to.  
The answer: this is the minimal execution environment supplied with AAP 2.4, which is the latest release of Ansible Automation Platform.  
Another image that comes with the platform is the supported execution environment, which also has the Ansible supported collections baked on top of the minimal execution environment.

For the purpose of this lab, as we are showing how to build an execution environment, we are starting from the minimal execution environment as the base image for our EE.

== ‚òëÔ∏è Task - Adding the collection to EE

Next step is to add the collection that we want to include in our execution environment.  
For this challenge, as we are adding the `ansible.netcommon` collection from the default Galaxy, we don't need to add an `ansible.cfg` to point to the Automation Hub used in this lab.

A simple collection definition for EE looks like this ‚Äî add this to the `execution-environment.yml` file after the `images` section:

[source,yaml]
----
dependencies:
  galaxy:
    collections:
      - ansible.netcommon
----

The above section specifies that we need to bake the `ansible.netcommon` collection into the execution environment.  
There are different dependencies you can specify for your execution environment in this section, like `python` and `system` dependencies, based on your automation needs.

One advantage of builder v3 is that you can specify dependencies inline, compared to builder v1 where you had to specify dependencies in a `requirements.yml` file.  
v3 gives you both options ‚Äî either specify inline or point to a requirements file.  

== ‚òëÔ∏è Task - Adding options to definition file

A mandatory bit you need to add to your execution-environment definition ‚Äî if you are building on top of minimal or supported EE ‚Äî is the `package_manager_path`.  
You need to do this because the downstream platform images are built on top of UBI-minimal, which uses `microdnf` instead of `dnf`.  
If you are using builder to build images on top of only UBI, Fedora, or CentOS, you do *not* need to specify the `package_manager_path`.

But as we are building on top of the minimal image, go ahead and add the following lines after the `dependencies` section:

[source,yaml]
----
options:
  package_manager_path: /usr/bin/microdnf
----

Go ahead and save this file using `Ctrl + S` or from the *File ‚Üí Save* option in the menu bar.

== ‚òëÔ∏è Task - Let's build our EE

This concludes building our definition file.  
Now let's go to the terminal window and type the following command to build our EE:

[source,shell]
----
ansible-builder build -v 3
----

A bit about the command: we are not specifying the definition file name as we used the default name, and `-v 3` signifies the verbosity level of the output.  
You will see the build steps when you run this command.  
Adding `-v 3` is optional.

[NOTE]
====
`-v 3` has *nothing* to do with version 3 ‚Äî it just specifies the verbosity level.  
Do not confuse it with `version: 3` in the definition file.
====

This command will take a minute or two to complete.

== ‚òëÔ∏è Task - Let's check what's built

Run the following command to check the image that was created:

[source,shell]
----
podman images
----

You will see that it builds an execution environment called `local/ansible-execution-env` by default ‚Äî this is our EE built with the collection we specified.  
You can also specify the name for your EE by adding a tag to the build command, for example:

[source,shell]
----
ansible-builder build -t local/netcommon-ee
----

You can also tag the image post-build using Podman:

[source,shell]
----
podman tag localhost/ansible-execution-env localhost/netcommon-ee
----

To verify if our EE was built correctly, run the following command to go inside the container image:

[source,shell]
----
podman run -it localhost/ansible-execution-env bash
----

Once you are inside the EE, run the collection list command to check if the collection is present inside the EE:

[source,shell]
----
ansible-galaxy collection list
----

The output should show the `ansible.netcommon` collection.  
Use the same method for all subsequent challenges to verify your EE.

üéâ Hurray! You have now created a basic execution environment.  
In the next challenge, we will look at how to pull collections from Automation Hub.

== ‚úÖ Next Challenge

Press the *Next* button below to go to the next challenge once you‚Äôve completed the tasks.

== üêõ Encountered an issue?

If you have encountered an issue or noticed something not quite right, please open an issue here:  
https://github.com/ansible/instruqt/issues/new
